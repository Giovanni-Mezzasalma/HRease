<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HRease - Log Dashboard</title>
  <!-- Bootstrap CSS per lo styling -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome per le icone -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    /* Stile personalizzato per il dashboard */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #f8f9fa;
    }
    
    .navbar-brand {
      font-weight: bold;
      color: #3498db !important;
    }
    
    .log-container {
      height: calc(100vh - 200px);
      min-height: 400px;
      overflow-y: auto;
      background-color: white;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .log-entry {
      padding: 10px;
      margin-bottom: 6px;
      border-radius: 4px;
      border-left: 4px solid transparent;
      transition: background-color 0.2s;
    }
    
    .log-entry:hover {
      background-color: rgba(0,0,0,0.025);
    }
    
    /* Colori per i diversi livelli di log */
    .log-debug { border-left-color: #6c757d; background-color: #f8f9fa; }
    .log-info { border-left-color: #17a2b8; background-color: #e3f2fd; }
    .log-warn { border-left-color: #ffc107; background-color: #fff3cd; }
    .log-error { border-left-color: #dc3545; background-color: #f8d7da; }
    
    .log-meta {
      background-color: rgba(0,0,0,0.03);
      border-radius: 4px;
      padding: 8px;
      margin-top: 6px;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .timestamp {
      color: #6c757d;
      font-size: 12px;
    }
    
    /* Stile per i filtri temporali */
    .date-filter {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .date-filter label {
      margin-bottom: 0;
      white-space: nowrap;
    }
    
    /* Stile per lo stato di aggiornamento */
    .auto-refresh-status {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .auto-refresh-active {
      background-color: #28a745;
    }
    
    .auto-refresh-paused {
      background-color: #dc3545;
    }
    
    /* Spinner per il caricamento */
    .spinner-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100px;
    }
    
    /* Badge per conteggio log */
    .source-badge {
      background-color: #3498db;
      color: white;
      font-size: 0.75em;
      padding: 0.25em 0.5em;
      border-radius: 1em;
      margin-left: 0.5em;
    }
  </style>
</head>
<body>
  <!-- Navbar con il titolo -->
  <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
    <div class="container">
      <a class="navbar-brand" href="#">
        <i class="fas fa-stream me-2"></i>
        HRease - Log Dashboard
      </a>
      <div class="d-flex">
        <div class="me-2">
          <span class="auto-refresh-status auto-refresh-active" id="refreshStatus"></span>
          <span id="refreshText">Auto-refresh active</span>
        </div>
        <button id="toggleRefreshBtn" class="btn btn-sm btn-outline-secondary">
          <i class="fas fa-pause"></i>
        </button>
      </div>
    </div>
  </nav>

  <div class="container">
    <!-- Filtri -->
    <div class="row mb-4">
      <!-- Selettore sorgente -->
      <div class="col-md-3 mb-3 mb-md-0">
        <label for="sourceSelect" class="form-label">Source</label>
        <select id="sourceSelect" class="form-select">
          <option value="" disabled selected>Select a source...</option>
          <!-- Le opzioni verranno popolate dinamicamente -->
        </select>
      </div>
      
      <!-- Selettore livello -->
      <div class="col-md-2 mb-3 mb-md-0">
        <label for="levelSelect" class="form-label">Level</label>
        <select id="levelSelect" class="form-select">
          <option value="">All levels</option>
          <option value="debug">Debug</option>
          <option value="info">Info</option>
          <option value="warn">Warning</option>
          <option value="error">Error</option>
        </select>
      </div>
      
      <!-- Input ricerca -->
      <div class="col-md-4 mb-3 mb-md-0">
        <label for="searchInput" class="form-label">Search</label>
        <input id="searchInput" type="text" class="form-control" placeholder="Search logs...">
      </div>
      
      <!-- Pulsante refresh -->
      <div class="col-md-3 d-flex align-items-end">
        <button id="refreshBtn" class="btn btn-primary w-100">
          <i class="fas fa-sync-alt me-1"></i> Refresh
        </button>
      </div>
    </div>
    
    <!-- Filtri temporali (nascosti inizialmente) -->
    <div class="row mb-4" id="dateFilters" style="display:none;">
      <div class="col-md-6 mb-3 mb-md-0">
        <div class="date-filter">
          <label for="fromDate" class="form-label">From:</label>
          <input type="datetime-local" id="fromDate" class="form-control">
        </div>
      </div>
      <div class="col-md-6">
        <div class="date-filter">
          <label for="toDate" class="form-label">To:</label>
          <input type="datetime-local" id="toDate" class="form-control">
        </div>
      </div>
    </div>
    
    <!-- Pulsante per mostrare/nascondere filtri temporali -->
    <div class="row mb-4">
      <div class="col-12">
        <button id="toggleDateFilters" class="btn btn-sm btn-outline-secondary">
          <i class="fas fa-calendar me-1"></i> Show date filters
        </button>
      </div>
    </div>
    
    <!-- Container per i log -->
    <div class="log-container p-3">
      <div id="logsOutput">
        <div class="text-center text-muted pt-5">
          <i class="fas fa-stream fa-3x mb-3"></i>
          <p>Select a source to view logs</p>
        </div>
      </div>
    </div>
    
    <!-- Paginazione -->
    <div class="d-flex justify-content-between align-items-center mt-3">
      <div>
        <span id="logCount" class="text-muted">0 logs</span>
      </div>
      <div>
        <button id="loadMoreBtn" class="btn btn-outline-primary" style="display: none;">
          Load more
        </button>
      </div>
    </div>
  </div>

  <!-- Script principale -->
  <script>
    /**
     * Dashboard di Log HRease
     * Script client-side per visualizzare e interagire con i log
     */
    document.addEventListener('DOMContentLoaded', function() {
      // Elementi DOM
      const logsOutput = document.getElementById('logsOutput');
      const sourceSelect = document.getElementById('sourceSelect');
      const levelSelect = document.getElementById('levelSelect');
      const searchInput = document.getElementById('searchInput');
      const refreshBtn = document.getElementById('refreshBtn');
      const fromDate = document.getElementById('fromDate');
      const toDate = document.getElementById('toDate');
      const toggleDateFilters = document.getElementById('toggleDateFilters');
      const dateFilters = document.getElementById('dateFilters');
      const logCount = document.getElementById('logCount');
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      const toggleRefreshBtn = document.getElementById('toggleRefreshBtn');
      const refreshStatus = document.getElementById('refreshStatus');
      const refreshText = document.getElementById('refreshText');
      
      // Stato dell'applicazione
      let state = {
        currentSource: '',
        currentPage: 1,
        autoRefresh: true,
        refreshInterval: null,
        logs: [],
        sources: []
      };
      
      // Inizializza l'intervallo di aggiornamento automatico (10 secondi)
      state.refreshInterval = setInterval(fetchLogs, 10000);
      
      // Configura gli event listeners
      refreshBtn.addEventListener('click', () => {
        state.currentPage = 1;
        fetchLogs();
      });
      
      sourceSelect.addEventListener('change', () => {
        state.currentSource = sourceSelect.value;
        state.currentPage = 1;
        fetchLogs();
      });
      
      levelSelect.addEventListener('change', () => {
        state.currentPage = 1;
        fetchLogs();
      });
      
      searchInput.addEventListener('input', debounce(() => {
        state.currentPage = 1;
        fetchLogs();
      }, 500));
      
      fromDate.addEventListener('change', () => {
        state.currentPage = 1;
        fetchLogs();
      });
      
      toDate.addEventListener('change', () => {
        state.currentPage = 1;
        fetchLogs();
      });
      
      toggleDateFilters.addEventListener('click', () => {
        const isVisible = dateFilters.style.display !== 'none';
        dateFilters.style.display = isVisible ? 'none' : 'flex';
        toggleDateFilters.innerHTML = isVisible ? 
          '<i class="fas fa-calendar me-1"></i> Show date filters' : 
          '<i class="fas fa-calendar-minus me-1"></i> Hide date filters';
      });
      
      loadMoreBtn.addEventListener('click', () => {
        state.currentPage++;
        fetchLogs(true);
      });
      
      toggleRefreshBtn.addEventListener('click', () => {
        state.autoRefresh = !state.autoRefresh;
        
        if (state.autoRefresh) {
          state.refreshInterval = setInterval(fetchLogs, 10000);
          refreshStatus.classList.remove('auto-refresh-paused');
          refreshStatus.classList.add('auto-refresh-active');
          refreshText.textContent = 'Auto-refresh active';
          toggleRefreshBtn.innerHTML = '<i class="fas fa-pause"></i>';
        } else {
          clearInterval(state.refreshInterval);
          refreshStatus.classList.remove('auto-refresh-active');
          refreshStatus.classList.add('auto-refresh-paused');
          refreshText.textContent = 'Auto-refresh paused';
          toggleRefreshBtn.innerHTML = '<i class="fas fa-play"></i>';
        }
      });
      
      // Carica le sorgenti al caricamento della pagina
      fetchSources();
      
      /**
       * Recupera tutte le sorgenti di log disponibili
       */
      function fetchSources() {
        fetch('/api/sources')
          .then(response => response.json())
          .then(data => {
            state.sources = data.sources || [];
            
            // Popola il selettore delle sorgenti
            sourceSelect.innerHTML = '<option value="" disabled selected>Select a source...</option>';
            
            state.sources.forEach(source => {
              const option = document.createElement('option');
              option.value = source;
              option.textContent = source;
              sourceSelect.appendChild(option);
            });
            
            // Se non ci sono sorgenti, mostra un messaggio
            if (state.sources.length === 0) {
              const option = document.createElement('option');
              option.value = '';
              option.textContent = 'No sources available';
              option.disabled = true;
              sourceSelect.appendChild(option);
            }
          })
          .catch(error => {
            console.error('Error fetching sources:', error);
            logsOutput.innerHTML = '<div class="alert alert-danger">Error loading sources</div>';
          });
      }
      
      /**
       * Recupera i log dalla sorgente selezionata
       * @param {boolean} append - Se true, aggiunge i nuovi log a quelli esistenti
       */
      function fetchLogs(append = false) {
        // Se non è stata selezionata una sorgente, non fare nulla
        if (!state.currentSource) {
          return;
        }
        
        // Costruisci l'URL con i parametri di query
        const source = state.currentSource;
        const level = levelSelect.value;
        const search = searchInput.value;
        const from = fromDate.value;
        const to = toDate.value;
        const page = state.currentPage;
        const limit = 50; // Numero di log per pagina
        
        let url = `/api/logs/${source}?page=${page}&limit=${limit}`;
        if (level) url += `&level=${level}`;
        if (search) url += `&search=${encodeURIComponent(search)}`;
        if (from) url += `&from=${encodeURIComponent(from)}`;
        if (to) url += `&to=${encodeURIComponent(to)}`;
        
        // Se non è un append, mostra un indicatore di caricamento
        if (!append) {
          logsOutput.innerHTML = `
            <div class="spinner-container">
              <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
            </div>
          `;
        }
        
        // Recupera i log dal server
        fetch(url)
          .then(response => response.json())
          .then(data => {
            const logs = data.logs || [];
            
            if (append) {
              // Aggiungi i nuovi log a quelli esistenti
              state.logs = [...state.logs, ...logs];
            } else {
              // Sostituisci i log esistenti
              state.logs = logs;
            }
            
            // Visualizza i log
            displayLogs(state.logs);
            
            // Aggiorna il conteggio e lo stato del pulsante "load more"
            logCount.textContent = `${state.logs.length} logs`;
            
            // Mostra il pulsante "load more" solo se ci sono abbastanza log
            loadMoreBtn.style.display = logs.length >= limit ? 'block' : 'none';
          })
          .catch(error => {
            console.error('Error fetching logs:', error);
            if (!append) {
              logsOutput.innerHTML = '<div class="alert alert-danger">Error loading logs</div>';
            }
          });
      }
      
      /**
       * Visualizza i log nella UI
       * @param {Array} logs - Array di oggetti log da visualizzare
       */
      function displayLogs(logs) {
        if (!logs || logs.length === 0) {
          logsOutput.innerHTML = '<div class="text-center text-muted">No logs found</div>';
          return;
        }
        
        let html = '';
        logs.forEach(log => {
          // Formatta il timestamp in formato locale
          const timestamp = new Date(log.timestamp).toLocaleString();
          const level = log.level || 'info';
          
          html += `
            <div class="log-entry log-${level}">
              <div class="d-flex justify-content-between align-items-start">
                <div>
                  <span class="badge bg-${getBadgeColor(level)}">${level.toUpperCase()}</span>
                </div>
                <small class="timestamp">${timestamp}</small>
              </div>
              <div class="log-message my-1">${escapeHtml(log.message)}</div>
              ${log.meta ? `<pre class="log-meta small">${escapeHtml(JSON.stringify(log.meta, null, 2))}</pre>` : ''}
            </div>
          `;
        });
        
        logsOutput.innerHTML = html;
      }
      
      /**
       * Determina il colore del badge in base al livello del log
       * @param {string} level - Livello del log (debug, info, warn, error)
       * @returns {string} - Classe Bootstrap per il badge
       */
      function getBadgeColor(level) {
        switch(level) {
          case 'error': return 'danger';
          case 'warn': return 'warning';
          case 'info': return 'info';
          case 'debug': return 'secondary';
          default: return 'primary';
        }
      }
      
      /**
       * Escapa caratteri HTML pericolosi per prevenire XSS
       * @param {string} unsafe - Stringa da escapare
       * @returns {string} - Stringa escapata
       */
      function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return JSON.stringify(unsafe);
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      
      /**
       * Debounce: limita la frequenza di esecuzione di una funzione
       * @param {Function} func - Funzione da eseguire
       * @param {number} delay - Ritardo in millisecondi
       * @returns {Function} - Funzione con debounce
       */
      function debounce(func, delay) {
        let timeoutId;
        return function() {
          const context = this;
          const args = arguments;
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            func.apply(context, args);
          }, delay);
        };
      }
    });
  </script>
</body>
</html>
